# Global Coding Standards & Guidelines

> These standards apply to all Claude Code sessions and projects.

---

## üîß General Coding Rules

* **Use 4 spaces (not tabs) for indentation** when creating new files
* **Analyze all affected files** and make necessary adjustments for consistency
* **Use clear and appropriate naming conventions** to prevent confusion or misleading logic flow
* **Apply Big O notation thinking** when writing or modifying code logic
* Analyze objectively as a veteran and professional software engineer
* Do not create markdown files that summarize what the prompts did unless explicitly requested

---

## üß† Algorithmic Efficiency Checklist

Before generating any code, ensure algorithmic efficiency by following this checklist:

### 1. Input Size Awareness
* Estimate the expected input size (n)
* Design with worst-case scenarios in mind

### 2. Time Complexity Bound
* **Target acceptable complexity: O(1), O(log n), O(n), O(n log n)**
* Avoid O(n¬≤) or worse unless explicitly required

### 3. Avoid Nested Loops on Same Dataset
* Flag any nested loops operating on the same dataset
* Replace with more efficient data structures or preprocessing techniques

### 4. Data Structure Choice
Select optimal data structures based on requirements:
* **HashMap / Set** ‚Üí O(1) lookups
* **Arrays / Lists** ‚Üí Fast sequential traversal
* **Heaps / Trees** ‚Üí Balanced trade-offs for insertion/search

### 5. Algorithm Optimization
Use efficient algorithms:
* Prefer **Merge Sort** over Bubble Sort
* Prefer **Binary Search** over linear scan

### 6. Space-Time Tradeoff
* Consider using extra memory to improve performance
* Apply caching (dictionaries, arrays) when beneficial

### 7. Lazy vs Eager Evaluation
* Use **generators/iterators** for large datasets
* Avoid eagerly loading unnecessary data into memory

### 8. Memoization or Dynamic Programming
* Apply when subproblems repeat frequently
* Convert exponential solutions into polynomial ones where possible

### 9. Profiling and Benchmarks
* Measure actual run-time with profiling tools
* Test code against large-scale inputs to validate complexity assumptions

### 10. Edge Case Handling
Confirm logic covers:
* n = 0
* Very large n
* Adversarial / worst-case inputs

---

## ‚úÖ Code Quality Requirements

Before delivering code:
* **Ensure time complexity is O(n) or better** whenever possible
* **Avoid unnecessary nested iterations**
* **Optimize using appropriate data structures and known algorithmic patterns**
* **Validate logic against edge cases and scalability requirements**

---

## üìù Documentation Standards

* Keep code self-documenting with clear variable and function names
* Add comments only where logic is non-obvious
* Document algorithm choices and Big O complexity for critical functions
* Include edge case handling in function documentation

---

## üéØ Best Practices Summary

1. **Performance First** - Always consider algorithmic efficiency
2. **Clarity Second** - Write code that others can understand
3. **Consistency Always** - Follow project conventions
4. **Test Edge Cases** - Don't just test happy paths
5. **Measure, Don't Guess** - Profile before optimizing

---

*Last Updated: 2025-12-04*
*Applies to: All Claude Code sessions*
